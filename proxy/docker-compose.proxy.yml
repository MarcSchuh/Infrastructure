services:
  # ------------------------------------------------------
  # Nginx (reverse proxy)
  # ------------------------------------------------------
  nginx:
    image: nginx:${NGINX_VERSION:-latest}
    container_name: ${NGINX_CONTAINER_NAME:-nginx_reverse_proxy}
    restart: ${RESTART_POLICY:-unless-stopped}
    env_file:
      - .env
    volumes:
      - ${DATA_DIR}/config/nginx.conf:/etc/nginx/nginx.conf:ro
      - ${DATA_DIR}/config/ssl-params.conf:/etc/nginx/ssl-params.conf:ro
      - ${DATA_DIR}/config/services-config:/etc/nginx/services-config:ro
      # Make ACME challenge folder available to Certbot
      - ${DATA_DIR}/certbot-challenges:/var/www/certbot-challenges
      - ${DATA_DIR}/certbot-etc:/etc/letsencrypt:ro
    ports:
      - "${HTTP_PORT:-80}:80"
      - "${HTTPS_PORT:-443}:443"
    networks:
      - proxy_network
      - jitsi_network
      - nextcloud_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    logging:
      driver: "loki"
      options:
        loki-url: "http://loki:3100/loki/api/v1/push"
        loki-pipeline-stages: |
          - json:
              expressions:
                timestamp: time
                level: level
                message: message
        loki-retries: "5"
        loki-batch-size: "400"
        loki-external-labels: "container_name={{.Name}},service=nginx"

  # ------------------------------------------------------
  # Certbot (handles Let's Encrypt certificates)
  # ------------------------------------------------------
  certbot:
    image: certbot/certbot:${CERTBOT_VERSION:-latest}
    container_name: ${CERTBOT_CONTAINER_NAME:-certbot_le}
    restart: no
    env_file:
      - .env
    volumes:
      # Where Certbot stores certificates
      - ${DATA_DIR}/certbot-etc:/etc/letsencrypt
      - ${DATA_DIR}/certbot-challenges:/var/www/certbot-challenges
      - ${DATA_DIR}/certbot-logs:/var/log/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
    healthcheck:
      test: ["CMD", "certbot", "certificates"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 10s
    networks:
      - proxy_network
    logging:
      driver: "loki"
      options:
        loki-url: "http://loki:3100/loki/api/v1/push"
        loki-pipeline-stages: |
          - json:
              expressions:
                timestamp: time
                level: level
                message: message
        loki-retries: "5"
        loki-batch-size: "400"
        loki-external-labels: "container_name={{.Name}},service=certbot"

  # Handle renew of the certificates
  certbot-renew:
    image: certbot/certbot:${CERTBOT_VERSION:-latest}
    container_name: ${CERTBOT_RENEW_CONTAINER_NAME:-certbot_renew}
    restart: ${RESTART_POLICY:-unless-stopped}
    volumes:
      - ${DATA_DIR}/certbot-etc:/etc/letsencrypt
      - ${DATA_DIR}/certbot-challenges:/var/www/certbot-challenges
      - ${DATA_DIR}/certbot-logs:/var/log/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
    entrypoint: >
      sh -c "
      apk add --no-cache docker-cli &&
      mkdir -p /etc/crontabs &&
      echo '0 3 * * * certbot renew --webroot -w /var/www/certbot-challenges --post-hook \"docker exec ${NGINX_CONTAINER_NAME} nginx -s reload\" >> /var/log/letsencrypt/renew.log 2>&1' > /etc/crontabs/root &&
      echo 'Crontab installed. Starting cron daemon...' &&
      crond -f -l 8
      "
    healthcheck:
      test: ["CMD", "certbot", "certificates"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 10s
    networks:
      - proxy_network
    logging:
      driver: "loki"
      options:
        loki-url: "http://loki:3100/loki/api/v1/push"
        loki-pipeline-stages: |
          - json:
              expressions:
                timestamp: time
                level: level
                message: message
        loki-retries: "5"
        loki-batch-size: "400"
        loki-external-labels: "container_name={{.Name}},service=certbot-renew"

networks:
  proxy_network:
    driver: ${NETWORK_DRIVER}
    external: true
  jitsi_network:
    external: true
  nextcloud_network:
    external: true

